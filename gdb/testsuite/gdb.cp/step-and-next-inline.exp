# Copyright 2019-2024 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

standard_testfile .cc

if { ![test_compiler_info gcc*] || ![supports_statement_frontiers] } {
    untested "this test needs gcc with statement frontiers"
    return -1
}

# Compile the test source with USE_NEXT_INLINE_H defined (when
# use_header is true), or not defined.
proc do_test { use_header } {
    global srcfile testfile

    set options {c++ debug nowarnings optimize=-O2}
    lappend options additional_flags=-gstatement-frontiers
    if { $use_header } {
	lappend options additional_flags=-DUSE_NEXT_INLINE_H
	set executable "$testfile-with-header"
	set hdrfile "step-and-next-inline.h"
	set prefix "use_header"
    } else {
	set executable "$testfile-no-header"
	set hdrfile "$srcfile"
	set prefix "no_header"
    }

    if { [prepare_for_testing "failed to prepare" $executable \
	      $srcfile $options] } {
	return -1
    }

    with_test_prefix $prefix {

    if {![runto_main]} {
	return
    }

    gdb_breakpoint tree_check

    # Check that GDB can correctly stop in `tree_check`.  On some
    # targets. gcc will use DW_AT_ranges to represent the addresses of
    # tree_check, and in some cases, will create an empty sub-range
    # for some of the tree_check code.  To really confuse things, gcc
    # will then set the DW_AT_entry_pc to point at the address of the
    # empty sub-range.
    #
    # The result of this is that GDB would stop at the DW_AT_entry_pc,
    # but then GDB would fail to realise that this address was inside
    # tree_check.
    for { set i 1 } { $i < 4 } { incr i } {
	gdb_test "continue" \
	    [multi_line \
		 "Breakpoint $::decimal\\.$i, (?:$::hex in )?tree_check \\(\[^\r\n\]+\\) at \[^\r\n\]+/$hdrfile:$::decimal" \
		 "$::decimal\\s+\[^\r\n\]+"] \
	    "stop at tree_check, $i"
    }

    clean_restart $executable

    if ![runto_main] {
	return
    }

    gdb_test "bt" "\\s*\\#0\\s+main.*" "in main"
    gdb_test "step" ".*" "step into get_alias_set"
    gdb_test "bt" "\\s*\\#0\\s+get_alias_set\[^\r\]*${srcfile}:.*" \
	"not in inline 1"
    gdb_test "next" ".*TREE_TYPE.*" "next step 1"
    gdb_test "bt" "\\s*\\#0\\s+get_alias_set\[^\r\]*${srcfile}:.*" \
	"not in inline 2"
    gdb_test "next" ".*TREE_TYPE.*" "next step 2"
    gdb_test "bt" "\\s*\\#0\\s+get_alias_set\[^\r\]*${srcfile}:.*" \
	"not in inline 3"
    gdb_test "next" ".*TREE_TYPE.*" "next step 3"
    gdb_test "bt" "\\s*\\#0\\s+get_alias_set\[^\r\]*${srcfile}:.*" \
	"not in inline 4"
    gdb_test "next" "return 0.*" "next step 4"
    gdb_test "bt" \
	"\\s*\\#0\\s+(main|get_alias_set)\[^\r\]*${srcfile}:.*" \
	"not in inline 5"

    clean_restart ${executable}

    if ![runto_main] {
	return
    }

    gdb_test "bt" "\\s*\\#0\\s+main.*" "in main pass 2"
    gdb_test "step" ".*" "step into get_alias_set pass 2"
    gdb_test "bt" "\\s*\\#0\\s+get_alias_set\[^\r\]*${srcfile}:.*" \
	"in get_alias_set pass 2"
    gdb_test "step" ".*TREE_TYPE.*" "step 1"
    gdb_test "bt" "\\s*\\#0\\s+get_alias_set\[^\r\]*${srcfile}:.*" \
	"not in inline 1 pass 2"
    gdb_test "step" ".*if \\(t->x != i\\).*" "step 2"
    gdb_test "bt" "\\s*\\#0\\s+\[^\r\]*tree_check\[^\r\]*${hdrfile}:.*" \
	"in inline 1 pass 2"
    gdb_test "step" ".*return x.*" "step 3"
    gdb_test "bt" "\\s*\\#0\\s+\[^\r\]*tree_check\[^\r\]*${hdrfile}:.*" \
	"return from inline 1 pass 2"
    gdb_test "step" ".*TREE_TYPE.*" "step 4"
    gdb_test "bt" "\\s*\\#0\\s+get_alias_set\[^\r\]*${srcfile}:.*" \
	"not in inline 2 pass 2"
    gdb_test "step" ".*if \\(t->x != i\\).*" "step 5"
    gdb_test "bt" "\\s*\\#0\\s+\[^\r\]*tree_check\[^\r\]*${hdrfile}:.*" \
	"in inline 2 pass 2"
    gdb_test "step" ".*return x.*" "step 6"
    gdb_test "bt" "\\s*\\#0\\s+\[^\r\]*tree_check\[^\r\]*${hdrfile}:.*" \
	"return from inline 2 pass 2"
    gdb_test "step" ".*TREE_TYPE.*" "step 7"
    gdb_test "bt" "\\s*\\#0\\s+get_alias_set\[^\r\]*${srcfile}:.*" \
	"not in inline 3 pass 2"
    gdb_test "step" ".*if \\(t->x != i\\).*" "step 8"
    gdb_test "bt" "\\s*\\#0\\s+\[^\r\]*tree_check\[^\r\]*${hdrfile}:.*" \
	"in inline 3 pass 2"
    gdb_test "step" ".*return x.*" "step 9"
    gdb_test "bt" "\\s*\\#0\\s+\[^\r\]*tree_check\[^\r\]*${hdrfile}:.*" \
	"return from inline 3 pass 2"
    gdb_test "step" "return 0.*" "step 10"
    gdb_test "bt" \
	"\\s*\\#0\\s+(main|get_alias_set)\[^\r\]*${srcfile}:.*" \
	"not in inline 4 pass 2"

    clean_restart ${executable}

    if ![runto_main] {
	return
    }

    gdb_test "bt" "\\s*\\#0\\s+main.*" "in main pass 3"
    gdb_test "step" ".*" "step into get_alias_set pass 3"
    gdb_test "bt" "\\s*\\#0\\s+get_alias_set\[^\r\]*${srcfile}:.*" \
	"in get_alias_set pass 3"
    gdb_test "step" ".*TREE_TYPE.*" "step 1 pass 3"
    gdb_test "bt" "\\s*\\#0\\s+get_alias_set\[^\r\]*${srcfile}:.*" \
	"not in inline 1 pass 3"
    gdb_test "step" ".*if \\(t->x != i\\).*" "step 2 pass 3"
    gdb_test "bt" "\\s*\\#0\\s+\[^\r\]*tree_check\[^\r\]*${hdrfile}:.*" \
	"in inline 1 pass 3"
    gdb_test_multiple "p t->x = 2" "change value pass 3" {
	-re ".*value has been optimized out.*$::gdb_prompt $" {
	    gdb_test "p xx.x = 2" ".* = 2.*" $gdb_test_name
	}
	-re ".* = 2.*$::gdb_prompt $" {
	    pass $gdb_test_name
	}
    }
    gdb_test "step" ".*abort.*" "step 3, pass 3"
    gdb_test "bt" "\\s*\\#0\\s+\[^\r\]*tree_check\[^\r\]*${hdrfile}:.*" \
	"abort from inline 1 pass 3"

    clean_restart ${executable}

    if ![runto_main] {
	return
    }

    gdb_test "bt" "\\s*\\#0\\s+main.*" "in main pass 4"
    gdb_test "skip tree_check" ".*" "skip tree_check pass 4"
    gdb_test "step" ".*" "step into get_alias_set pass 4"
    gdb_test "bt" "\\s*\\#0\\s+get_alias_set\[^\r\]*${srcfile}:.*" \
	"in get_alias_set pass 4"
    gdb_test "step" ".*TREE_TYPE.*" "step 1 pass 4"
    gdb_test "bt" "\\s*\\#0\\s+get_alias_set\[^\r\]*${srcfile}:.*" \
	"not in inline 1 pass 4"
    gdb_test "step" ".*TREE_TYPE.*" "step 2 pass 4"
    gdb_test "bt" "\\s*\\#0\\s+get_alias_set\[^\r\]*${srcfile}:.*" \
	"not in inline 2 pass 4"
    gdb_test "step" ".*TREE_TYPE.*" "step 3 pass 4"
    gdb_test "bt" "\\s*\\#0\\s+get_alias_set\[^\r\]*${srcfile}:.*" \
	"not in inline 3 pass 4"
    gdb_test "step" "return 0.*" "step 4 pass 4"
    gdb_test "bt" \
	"\\s*\\#0\\s+(main|get_alias_set)\[^\r\]*${srcfile}:.*" \
	"not in inline 4 pass 4"
    }
}

do_test 0
do_test 1
