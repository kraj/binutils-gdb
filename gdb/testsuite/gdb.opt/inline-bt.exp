# Copyright 2008-2024 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

standard_testfile .c inline-markers.c

set opts {debug additional_flags=-Winline}
lappend_include_file opts $srcdir/lib/attributes.h

if {[prepare_for_testing "failed to prepare" $testfile \
	 [list $srcfile $srcfile2] $opts]} {
    return -1
}

runto_main

get_debug_format
if { [skip_inline_frame_tests] } {
    untested "skipping inline frame tests"
    return
}

# Run inline function backtrace tests, compile with binary with OPT_LEVEL
# optimisation level.  OPT_LEVEL should be a string like 'O0', 'O1', etc.
# No leading '-' is needed on OPT_LEVEL, that is added in this proc.
proc run_test { opt_level } {

    set local_opts $::opts
    lappend local_opts "additional_flags=-$opt_level"

    if {[prepare_for_testing "failed to prepare" ${::testfile}-${opt_level} \
	     [list $::srcfile $::srcfile2] $local_opts]} {
	return
    }

    runto_main

    set line1 [gdb_get_line_number "set breakpoint 1 here" ${::srcfile2}]
    gdb_breakpoint $::srcfile2:$line1

    with_test_prefix "first stop at bar" {
	gdb_continue_to_breakpoint "continue to bar" \
	    ".*set breakpoint 1 here.*"
	gdb_test "backtrace" "#0  bar.*#1  .*main.*" "backtrace from bar"
	gdb_test "info frame" ".*called by frame.*" "bar not inlined"
    }

    with_test_prefix "second stop at bar" {
	gdb_continue_to_breakpoint "continue to bar" \
	    ".*set breakpoint 1 here.*"
	gdb_test "backtrace" "#0  bar.*#1  .*func1.*#2  .*main.*" \
	    "backtrace from bar"
	gdb_test "up" "#1  .*func1.*" "up from bar"
	gdb_test "info frame" ".*inlined into frame.*" "func1 inlined"
    }

    with_test_prefix "third stop at bar" {
	gdb_continue_to_breakpoint "continue to bar" \
	    ".*set breakpoint 1 here.*"
	gdb_test "backtrace" "#0  bar.*#1  .*func1.*#2  .*func2.*#3  .*main.*" \
	    "backtrace from bar"
	gdb_test "up" "#1  .*func1.*" "up from bar"
	gdb_test "info frame" ".*inlined into frame.*" "func1 inlined"
	gdb_test "up" "#2  .*func2.*" "up from func1"
	gdb_test "info frame" ".*inlined into frame.*" "func2 inlined"
    }

    # A regression test for having a backtrace limit that forces unwinding
    # to stop after an inline frame.  GDB needs to compute the frame_id of
    # the inline frame, which requires unwinding past all the inline
    # frames to the real stack frame, even if that means bypassing the
    # user visible backtrace limit.  See PR backtrace/15558.
    #
    # Set a backtrace limit that forces an unwind stop after an inline
    # function.
    gdb_test_no_output "set backtrace limit 2"
    # Force flushing the frame cache.
    gdb_test "maint flush register-cache" "Register cache flushed."
    gdb_test "up" "#1  .*func1.*" "up from bar"
    gdb_test "info frame" ".*in func1.*" "info frame still works"
    # Verify the user visible limit works as expected.
    gdb_test "up" "Initial frame selected; you cannot go up." "up hits limit"
    gdb_test "backtrace" "#0  bar.*#1  .*func1.*" "backtrace hits limit"

    set line2 [gdb_get_line_number "b/p in not_inline_func" $::srcfile]
    set line3 [gdb_get_line_number "bt line in main" $::srcfile]

    gdb_breakpoint $::srcfile:$line2

    gdb_continue_to_breakpoint "stop in not_inline_func" \
	".*b/p in not_inline_func.*"
    gdb_test "bt" \
	[multi_line \
	     "^#0\\s+not_inline_func \\(\[^)\]+\\) at \[^\r\n\]+$::srcfile:$line2" \
	     "#1\\s+$::hex in main \\(\\) at \[^\r\n\]+$::srcfile:$line3"] \
	"bt from not_inline_func to main"
    gdb_test "frame 1" \
	[multi_line \
	     "^#1\\s+$::hex in main \\(\\) at \[^\r\n\]+$::srcfile:$line3" \
	     "$line3\\s+not_inline_func \\(return_one \\(\\)\\);\[^\r\n\]+"] \
	"select frame for main from not_inline_func"
}

foreach_with_prefix opt_level { O0 Og O1 O2 } {
    run_test $opt_level
}
